# Висновки до завдання 1 - task_1.py

# ДЗ: Розбиття суми на монети — жадібний алгоритм vs динамічне програмування

## Функції

- `find_coins_greedy(amount, coins=[50,25,10,5,2,1])` — повертає словник {номінал: кількість}, вибираючи найбільші монети спочатку.
  - Складність: O(k), де k — кількість номіналів (після сортування, яке константне для фіксованого набору монет).
- `find_min_coins(amount, coins=[50,25,10,5,2,1])` — DP (bottom-up) знаходить мінімальну кількість монет; повертає словник {номінал: кількість}.
  - Час: O(amount·k), Пам’ять: O(amount).

## Коректність

Для канонічних систем монет на кшталт [50,25,10,5,2,1] жадібний алгоритм дає оптимальне рішення. Для довільних наборів монет — не гарантовано.

## Порівняння ефективності (практично)

Нижче — запуск `task_1.py` зі зразковими сумами. Greedy працює майже миттєво й масштабується лінійно відносно k. DP масштабується лінійно відносно суми та гарантує мінімальну кількість монет.

```
Сума: 113
  Greedy : {50: 2, 10: 1, 2: 1, 1: 1}
  DP     : {1: 1, 2: 1, 10: 1, 50: 2}
  Час (Greedy) ~ 0.000004s  |  Час (DP) ~ 0.000053s
------------------------------------------------------------
Сума: 9999
  Greedy : {50: 199, 25: 1, 10: 2, 2: 2}
  DP     : {2: 2, 10: 2, 25: 1, 50: 199}
  Час (Greedy) ~ 0.000002s  |  Час (DP) ~ 0.005752s
------------------------------------------------------------
Сума: 123456
  Greedy : {50: 2469, 5: 1, 1: 1}
  DP     : {1: 1, 5: 1, 50: 2469}
  Час (Greedy) ~ 0.000004s  |  Час (DP) ~ 0.103477s
------------------------------------------------------------
```

## Висновки

1. **Greedy**: надзвичайно швидкий (O(k)), простий і підходить для «канонічних» наборів монет — наприклад, [50,25,10,5,2,1]. У таких системах він повертає мінімальну кількість монет і практично оптимальний для великих сум.
2. **DP**: універсальний метод, **завжди** знаходить мінімальну кількість монет для будь-якого набору номіналів, але має вищу вартість — O(amount·k) часу та O(amount) пам’яті. Для дуже великих сум це відчутно повільніше за Greedy.
3. **Що обрати**: якщо набір монет фіксований і «канонічний» (як у завданні) — Greedy є найефективнішим. Якщо набір довільний або потрібно **гарантовано мінімальну** кількість монет — краще використовувати DP.

# Висновки до завдання 2 - monte_carlo_integral.py

# Метод Монте-Карло для обчислення визначеного інтеграла

**Функція:** \( f(x) = x^2 \)  
**Інтервал інтегрування:** \([0, 2]\)

Аналітичний розв’язок:

$$
\int_{0}^{2} x^2\,dx = \left.\frac{x^3}{3}\right|_{0}^{2} = \frac{8}{3} \approx 2.6666666667.
$$

## Алгоритм Монте-Карло

Оцінка інтеграла:

$$
\hat I_N = (b-a)\cdot \frac{1}{N}\sum_{i=1}^{N} f(U_i), \quad U_i \sim \mathcal U(a,b).
$$

Оцінка стандартної похибки:

$$
SE = (b-a)\sqrt{\tfrac{\widehat{\mathrm{Var}}[f(U)]}{N}}, \quad
95\%\ \mathrm{CI} = \hat I_N \pm 1.96\cdot SE.
$$

## Запуск демо

```python
python monte_carlo_integral.py
```

## Результати (приклад виводу)

Аналітичне значення: 2.666666666667 (очікувано 8/3 ≈ 2.6666666667)

n= 1,000 | MC=2.6569839567 SE≈0.075755 95% CI=(2.5085042474, 2.8054636661)
n= 10,000 | MC=2.6415429971 SE≈0.023777 95% CI=(2.5949045892, 2.6881454049)
n= 100,000 | MC=2.6790954043 SE≈0.007538 95% CI=(2.6561766339, 2.6857247747)
n=1,000,000 | MC=2.6666950791 SE≈0.002385 95% CI=(2.6620199322, 2.6713702260)

## Перевірка через SciPy (`quad`)

```python
import scipy.integrate as spi

def f_scalar(x: float) -> float:
    return x*x

a, b = 0.0, 2.0
result, error = spi.quad(f_scalar, a, b)
print("SciPy quad:", result, "abs_error≈", error)
# Очікуване: 2.666666666666667  ~ 3e-14
```

Отриманий quad результат збігається з аналітичним значенням і має дуже малу оцінену абсолютну похибку.

## Висновки

- **Коректність Монте-Карло.** Оцінки, отримані методом Монте-Карло, узгоджуються з еталонним значенням `8/3 ≈ 2.6666666667`. Зі зростанням `N` точкова оцінка наближається до істини, а 95% довірчий інтервал містить `8/3`.

- **Порівняння з `quad`.** Функція `scipy.integrate.quad` дає результат, що практично збігається з аналітичним і має дуже малу оцінену абсолютну похибку (порядку `1e-14` для цієї задачі). Оцінки Монте-Карло при великих `N` потрапляють у цей діапазон.

- **Точність і масштабованість.** Стандартна похибка Монте-Карло зменшується приблизно як `SE ∝ 1/sqrt(N)`. Щоб зменшити похибку в 2 рази, потрібно приблизно у 4 рази більше вибірок.

- **Практичний вибір методу.** Для простих одновимірних інтегралів найкращими є аналітика або `quad` (швидше й точніше). Монте-Карло доцільний для високих розмірностей, складних областей інтегрування або коли класичні квадратури незручні/неможливі.

- **Підсумок.** Реалізація Монте-Карло правильна; результати статистично збігаються як з аналітичним значенням `8/3`, так і з результатом `quad`.
